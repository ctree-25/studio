/**
 * Core Philosophy: This ruleset enforces a strict user-ownership security model. All user-specific data, such as player and coach profiles, is nested within a user's own document tree (`/users/{userId}/...`), ensuring that only the authenticated owner can access or modify their private information.
 * Data Structure: The data is organized hierarchically. Core user information is at `/users/{userId}`. Specific profiles like `/playerProfiles` and `/coachProfiles` are subcollections under the user's document. Shared or public data, like `/targetSchools`, resides in top-level collections.
 * Key Security Decisions:
 *  - Strict Ownership: Access to any path under `/users/{userId}` is restricted to the user whose UID matches `{userId}`.
 *  - Public Reads: The `/targetSchools` collection is publicly readable by any client, but writes are disabled pending a clear administrative or ownership model. This prevents unauthorized data modification.
 *  - User Listing Disabled: To protect user privacy, it is not possible to list all documents in the `/users` collection.
 *  - Shared Access for Feedback: Access to `/playerProfiles/{playerProfileId}/coachFeedbacks` is shared. The player can read all feedback on their profile, but only the coach who created a specific feedback entry can create, update, or delete it.
 * Denormalization for Authorization: To ensure performant and secure rules, this model relies on denormalized user IDs. For example, a `CoachFeedback` document must contain a `coachUserId` field. This allows rules to directly check the ID against the authenticated user's UID (`request.auth.uid`) without performing slow and costly `get()` operations on other documents.
 * Structural Segregation: Private user data (profiles) is kept in user-owned subcollections, while public data (schools) is in a separate top-level collection. This separation simplifies rules and improves security for list operations.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // Helper functions for common authorization patterns
    function isSignedIn() {
      return request.auth != null;
    }

    // Checks if the requesting user is the owner of the document based on a path parameter.
    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }

    // Checks if a document exists and if the user is the owner. Used for update/delete.
    function isExistingOwner(userId) {
      return isOwner(userId) && resource != null;
    }

    /**
     * @description Manages user profile documents, which store basic account information.
     * @path /users/{userId}
     * @allow (create) A new user with UID 'user123' creating their own document at `/users/user123`.
     * @deny (get) User 'user456' trying to read the document at `/users/user123`.
     * @deny (list) Any user trying to list all documents in the `/users` collection.
     * @principle Enforces self-creation and strict ownership of a user's root document.
     */
    match /users/{userId} {
      allow get: if isOwner(userId);
      allow list: if false;
      allow create: if isOwner(userId) && request.resource.data.id == userId;
      allow update: if isExistingOwner(userId) && request.resource.data.id == resource.data.id;
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Manages player profiles, which are owned by and nested under a user.
     * @path /users/{userId}/playerProfiles/{playerProfileId}
     * @allow (create) User 'user123' creating their own profile at `/users/user123/playerProfiles/profile_abc`.
     * @allow (list) User 'user123' listing all of their own profiles.
     * @deny (update) User 'user456' trying to update a profile at `/users/user123/playerProfiles/profile_abc`.
     * @principle Restricts access to a user's own data tree, ensuring data privacy.
     */
    match /users/{userId}/playerProfiles/{playerProfileId} {
      allow get: if isOwner(userId);
      allow list: if isOwner(userId);
      allow create: if isOwner(userId) && request.resource.data.userId == userId;
      allow update: if isExistingOwner(userId) && request.resource.data.userId == resource.data.userId;
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Manages coach profiles, which are owned by and nested under a user.
     * @path /users/{userId}/coachProfiles/{coachProfileId}
     * @allow (create) User 'user123' creating their own profile at `/users/user123/coachProfiles/profile_xyz`.
     * @allow (list) User 'user123' listing all of their own profiles.
     * @deny (update) User 'user456' trying to update a profile at `/users/user123/coachProfiles/profile_xyz`.
     * @principle Restricts access to a user's own data tree, ensuring data privacy.
     */
    match /users/{userId}/coachProfiles/{coachProfileId} {
      allow get: if isOwner(userId);
      allow list: if isOwner(userId);
      allow create: if isOwner(userId) && request.resource.data.userId == userId;
      allow update: if isExistingOwner(userId) && request.resource.data.userId == resource.data.userId;
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Manages player profiles stored at the top-level. This rule allows signed-in users to view profiles, but only the owner can modify them.
     * @path /playerProfiles/{playerProfileId}
     * @allow (get) Any signed-in user reading `/playerProfiles/profile_abc`.
     * @allow (update) The user whose UID matches `resource.data.userId` updating the document.
     * @deny (delete) A user who is not the owner trying to delete the profile.
     * @principle Enforces document ownership for writes while allowing broader read access.
     */
    match /playerProfiles/{playerProfileId} {
      allow get: if isSignedIn();
      allow list: if isSignedIn();
      allow create: if isSignedIn() && request.resource.data.userId == request.auth.uid;
      allow update: if resource != null && isOwner(resource.data.userId) && request.resource.data.userId == resource.data.userId;
      allow delete: if resource != null && isOwner(resource.data.userId);

      /**
       * @description Manages feedback from a coach to a player.
       * @path /playerProfiles/{playerProfileId}/coachFeedbacks/{coachFeedbackId}
       * @allow (create) A coach creating feedback, where the new document's `coachUserId` matches their auth UID.
       * @allow (get) The player or the coach associated with the feedback reading it.
       * @deny (update) The player trying to update the feedback a coach left for them.
       * @principle Implements shared access using denormalized IDs for authorization.
       */
      match /coachFeedbacks/{coachFeedbackId} {
        // Helper to check if the requester is the player who owns the parent profile.
        // This requires a `get()` call because the parent document's ownership determines access.
        function isPlayerOwner() {
          return get(/databases/$(database)/documents/playerProfiles/$(playerProfileId)).data.userId == request.auth.uid;
        }
        
        // Helper to check if the requester is the coach who wrote the feedback.
        // This uses a denormalized ID on the feedback document itself, avoiding a `get()`.
        function isFeedbackAuthor(docData) {
          return isSignedIn() && request.auth.uid == docData.coachUserId;
        }

        // Feedback can be read by the player who owns the profile or the coach who wrote it.
        allow get: if resource != null && (isPlayerOwner() || isFeedbackAuthor(resource.data));
        // Only the player who owns the profile can list all of its feedback.
        allow list: if isPlayerOwner();
        // Feedback can only be created by the coach, who must embed their own user ID.
        allow create: if isFeedbackAuthor(request.resource.data) && request.resource.data.playerProfileId == playerProfileId;
        // Feedback can only be updated/deleted by the coach who authored it. Relational IDs are immutable.
        allow update: if resource != null && isFeedbackAuthor(resource.data) && request.resource.data.playerProfileId == resource.data.playerProfileId && request.resource.data.coachUserId == resource.data.coachUserId;
        allow delete: if resource != null && isFeedbackAuthor(resource.data);
      }
    }

    /**
     * @description Manages target school information, which is publicly readable.
     * @path /targetSchools/{targetSchoolId}
     * @allow (get) Any user, signed-in or not, reading `/targetSchools/school_xyz`.
     * @deny (create) Any user trying to create a new school document.
     * @principle Provides public read access but restricts writes until a secure ownership model is defined.
     */
    match /targetSchools/{targetSchoolId} {
      allow get: if true;
      allow list: if true;
      // CRITICAL: Cannot implement owner-only writes. The 'TargetSchool' entity is missing an 'ownerId' or 'authorId' field.
      allow create: if false; // TODO: Add owner validation once the schema is updated with an ownership field.
      allow update: if false; // TODO: Add owner validation once the schema is updated with an ownership field.
      allow delete: if false; // TODO: Add owner validation once the schema is updated with an ownership field.
    }
  }
}